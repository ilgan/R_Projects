---
title: "HW6"
author: "iganelin"
date: "`r format(Sys.Date())`"
output:
  github_document: default
---

#Homework 06: Data wrangling wrap up (Due date 10/11/17)

### Loading libraries
```{r message=FALSE}
library(gapminder)
library(singer)
library(tidyverse)
library(knitr)
library(forcats)
library(magrittr)
#library(plyr)
library(dplyr)
library(meme)
library(readr)
library(tidyr)
library(stringr)
library(ggplot2)
```

```{r message=FALSE, warning=FALSE, error=FALSE }
u <- "http://i0.kym-cdn.com/entries/icons/mobile/000/000/745/success.jpg"
#meme(u, "Homework 6", "Yes! Give me more!")
mmplot(u) + mm_caption("Homework 6", "Yes! Give me more!", color="purple")
```

##1. Character data

We wil start from the loading the libraries for this excercise.

```{r}
library(tidyverse)
library(stringr)
```
Lets write a few strings.
```{r}
string1 <- "This is definitely string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
str_c("x", "y", "z")
str_c(string1, ". ", string2)
#or
str_c(string1, string2, sep = ", ")
```

### Character Data
####14.2.5 Exercises

1. In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions?

The difference between paste() and paste0() is that the argument "sep"" by default is ” ” (paste) and “” (paste0). It can be changed in the fuction itself.

- What stringr function are they equivalent to?

paste() => str_c(..., sep = " ", collapse = NULL)
paste0() => str_c(..., sep = "", collapse = NULL)

- How do the functions differ in their handling of NA?

Let's see how they work:
```{r}
str_c(c("a", NA, "b"), "-d")
paste(c("a", NA, "b"), "-d")
paste0(c("a", NA, "b"), "-d")
```
....so as we can see from the examples above, str_c does recognize NA, whereas paste() and paste0() both read NA as a string.

2. In your own words, describe the difference between the sep and collapse arguments to str_c().

Argument "sep" is used when we want to insert a string between the input vectors.
Argument "collapse" is used when  we want to combine input vectors into one string.

3. Use str_length() and str_sub() to extract the middle character from a string. 
```{r}
string <- "This is defiNitely string"
#string <- "12345" #for testing purposes
ln <- str_length(string)
str_sub(string, start=ln/2+1, end=ln/2+1)
```
- What will you do if the string has an even number of characters?

In that case we can extract the middle-1 or middle+1 character instead, or output "your character has even number of caracters" forcing the user to adjust the input string, and/or output an error.

4. What does str_wrap() do? When might you want to use it?

```{r}
thanks_path <- file.path(R.home("doc"), "THANKS")
thanks <- str_c(readLines(thanks_path), collapse = "\n")
thanks <- word(thanks, 1, 3, fixed("\n\n"))
cat(str_wrap(thanks), "\n")
```

This is a wrapper around stri_wrap which implements the Knuth-Plass paragraph wrapping algorithm, where the function breaks text paragraphs into lines, of total width. We might wanna use it in the case when the lines' width is important, fixed screen sizes for example.

5. What does str_trim() do? What’s the opposite of str_trim()?
```{r}
string <- "   This is definitely string   "
string
str_trim(string)
```
str_trim() - trims all the leading and trailing whitespaces from the string.
The opposite to str_trim() function is str_pad().

6. Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.
```{r}
x = c("a", "b", "c")
y = c("")

func <- function(input) {
  output = ""
  if (length(input) == 1)
  {
    output <- str_c(input)
    writeLines("Your output is of the size 0") #zero length case
  }
  else if (length(input) == 2)
  {
    output <- str_c(output, input[1], " and ", input[2])
  }
  else
  {
    for (i in 1:(length(input)-2))
    {
      output <- str_c(output, input[i], ", ")
    }
    output <- str_c(output, input[length(input)-1], " and ", input[length(input)])
  }
  writeLines(output)
}

func(y)
func(x)
```
####14.3.1.1 Exercises


7. Explain why each of these strings don’t match a \: "\", "\\", "\\\".

8. How would you match the sequence "'\?

9. What patterns will the regular expression \..\..\.. match? How would you represent it as a string?


####14.3.2.1 Exercises

10. How would you match the literal string "$^$"?

11. Given the corpus of common words in stringr::words, create regular expressions that find all words that:
- Start with “y”.
- End with “x”
- Are exactly three letters long. (Don’t cheat by using str_length()!)
- Have seven letters or more.

Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words.


####14.3.3.1 Exercises

12. Create regular expressions to find all words that:

- Start with a vowel.

- That only contain consonants. (Hint: thinking about matching “not”-vowels.)

- End with ed, but not with eed.

- End with ing or ise.

13. Empirically verify the rule “i before e except after c”.

14. Is “q” always followed by a “u”?

15. Write a regular expression that matches a word if it’s probably written in British English, not American English.
16. Create a regular expression that will match telephone numbers as commonly written in your country.


####14.3.4.1 Exercises

17. Describe the equivalents of ?, +, * in {m,n} form.

18. Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.)
- ^.*$
- "\\{.+\\}"
- \d{4}-\d{2}-\d{2}
- "\\\\{4}"

19. Create regular expressions to find all words that:
- Start with three consonants.
- Have three or more vowels in a row.
- Have two or more vowel-consonant pairs in a row.

20. Solve the beginner regexp crosswords at https://regexcrossword.com/challenges/beginner.


####14.3.5.1 Exercises

21. Describe, in words, what these expressions will match:
- (.)\1\1
- "(.)(.)\\2\\1"
- (..)\1
- "(.).\\1.\\1"
- "(.)(.)(.).*\\3\\2\\1"

22. Construct regular expressions to match words that:

- Start and end with the same character.

- Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.)

- Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.)



####14.4.2 Exercises

23. For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls.

- Find all words that start or end with x.

- Find all words that start with a vowel and end with a consonant.

- Are there any words that contain at least one of each different vowel?

24. What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?)


####14.4.3.1 Exercises

25. In the previous example, you might have noticed that the regular expression matched “flickered”, which is not a colour. Modify the regex to fix the problem.

26. From the Harvard sentences data, extract:
- The first word from each sentence.
- All words ending in ing.
- All plurals.


####14.4.4.1 Exercises

27. Find all words that come after a “number” like “one”, “two”, “three” etc. Pull out both the number and the word.

28. Find all contractions. Separate out the pieces before and after the apostrophe.



####14.4.5.1 Exercises

29. Replace all forward slashes in a string with backslashes.

30. Implement a simple version of str_to_lower() using replace_all().

31. Switch the first and last letters in words. Which of those strings are still words?




##2. Writing functions
- If you plan to complete the homework where we build an R package, write a couple of experimental functions exploring some functionality that is useful to you in real life and that might form the basis of your personal package.
We are going to use the data from the real wind turbine in form of csv. First function wil read this file and clean it up.

```{r}
read_wind_data <- function(input, save_flag){
  #Reads the wind turbine data CSV, cleans and prints it out.
  gtm.rawData <- read.csv(input, header = TRUE)
  gtm.dat <- within(gtm.rawData, rm("X.GV.SD_04","X.GV.SD_05","X.GV.SD_38", "X.GV.HRR_GeneratorWindingTemp.1"))
  c_names <- colnames(gtm.dat, do.NULL = TRUE, prefix = "col")
  raw_data <- str_replace(c_names, "X.GV.", "")
  names(gtm.dat) <- raw_data

  return(gtm.dat)
}
```

Functoin creates dir in main folder
```{r}
gtm.dat <- read_wind_data("10.0.103.10.csv", FALSE)
```

```{r}
mkdirs <- function(fp) {
    if(!file.exists(fp)) {
        mkdirs(dirname(source_local(), fp))
        dir.create(fp)
    }
} 
```

Function plots var1 against var2 from data-frame df and saves if save_flag == TRUE:
```{r}
plot_and_save <- function(df, var1, var2, save_flag){
    my_plot <- ggplot(df, aes(df[[var1]], df[[var2]])) +
      geom_point() +
      geom_smooth(se=FALSE)
  
    if(save_flag == TRUE){
    #mkdirs(media)
      ggsave("media/my_plot.png", plot = my_plot)
    }
}
```

```{r}
plot_and_save(gtm.dat, "HRR_WTCorrectedWindSpeed", "HRR_kW", TRUE)
```

PCA plus Linear regression
```{r}
end = ncol(gtm.dat)
gtm.gentemp <- gtm.dat[,end]
gtm.vars <- gtm.dat[,3:end-1]

le_lin_fit <- function(vars, gentemp) {
  PCA <- prcomp(vars, center = TRUE, scale. = TRUE) 
  print(PCA$rotation)
  plot(PCA, type = "l")
  summary(PCA)
  #the_fit <- lm(gentemp ~ gtm.dat)
  #the_fit <- lm(gentemp ~ PCA$rotation[,1], PCA$rotation[,2])
  the_fit <- lm(gtm.gentemp ~ gtm.vars$HRR_kVAR + gtm.vars$HRR_WTCorrectedWindSpeed)
  coef(the_fit)
  }
le_lin_fit(gtm.vars, gtm.gentemp)
```


##3. Work with the candy data
- The ![excersise](http://stat545.com/hw07_2015_data-wrangling-candy.html) from 2015
- The original work ![here](https://github.com/jennybc/candy)

Calculate the joy/dispare scores in separate columns. Joy is (+1), Dispare is (+1), overall Joy - Dispare.
#```{r message=FALSE, warning=FALSE}
```{r}
#library(readr)
#suppressPackageStartupMessages(library(dplyr))
#library(tidyr)
#library(stringr)
#library(ggplot2)

raw <- read_csv("CANDY-HIERARCHY-2015 SURVEY-Responses.csv",
                col_types = cols(
                  Timestamp = col_datetime("%m/%d/%Y %H:%M:%S")
                ))

raw_with_id <- raw %>%
	dplyr::mutate(id = sprintf("ID%04d", row_number())) %>%
	select(id, age = starts_with("How"), everything())

raw_with_id_scores <- raw_with_id %>%
  mutate(j_score = apply(raw_with_id, 1, function(x) sum(x=="JOY", na.rm=TRUE))) %>% 
  mutate(d_score = apply(raw_with_id, 1, function(x) sum(x=="DESPAIR", na.rm=TRUE))) %>% 
  mutate(tot_score = j_score - d_score)
#View(raw_with_id_scores)
```

Copy the scores to the data frame. Adding some left_join practice, because why not? ;)

```{r message=FALSE, warning=FALSE}
#raw_with_id_scores$age <- factor(raw_with_id_scores$age)
age_joy_des <- raw_with_id_scores %>%
	group_by(age) %>%
	summarise(j_score_tot = sum(j_score))

#  mutate(if (age == age){j_score_tot = sum(j_score)})

#age_joy_des <- raw_with_id_scores %>%
#	cbind(age_joy_des[!names(DF2) %in% names(DF1)])

#View(age_joy_des)
  
age_des_des <- raw_with_id_scores %>%
  group_by(age) %>%
  summarise(d_score_tot = sum(d_score))

age_stats <- left_join(age_joy_des, age_des_des)
  
#View(age_stats)
age_stats
dat <- age_stats[!is.na(as.numeric(as.character(age_stats$age))) | !(age_stats$age>120),]

View(dat)

#Clean data from the strings and redicoulous age numbers
dat$age <- as.integer(dat$age) 
typeof(dat$age)
dat_cleaned <- dat[with(dat, !(age >= 120 | age < 3), ordered = TRUE), ]
View(dat_cleaned)
```

Let's see how candy-loving and candy-neutral people vary by age:

```{r}
plot_j <- ggplot(dat_cleaned, aes(x = age, y = j_score_tot, color = age)) +
  	geom_point() +
	geom_smooth() +
	labs(title="Distribution of candy loving people by age")
ggsave("media/neutral_score_by_age_plot.png", plot = plot_j)
plot(plot_j)

plot_d <- ggplot(dat_cleaned, aes(x = age, y = d_score_tot, color = age)) +
  	geom_point() +
	geom_smooth() +
	labs(title="Distribution of candy neutral people by age")
ggsave("media/joy_score_by_age_plot.png", plot = plot_d)
plot(plot_d)
```

Both graphs look about the same, except for the actual values. It means that the distribution of people loving and neutral to candies is the same. With the peak at about 32 years old and slowly going down after that.


##4. Work with the singer data

##5. Work with a list

###Background basics

####Vectors and lists review of vectors, lists, and indexing
```{r}
library(purrr)
(v_log <- c(TRUE, FALSE, FALSE, TRUE))
(v_int <- 1:4)
(v_doub <- 1:4 * 1.2)
(v_char <- letters[1:4])
```

- Define the vectors above or similar. Use the family of is.star() functions to confirm vector type, e.g. is.logical(). You will need to guess or look some of them up. Long-term, you may wish to explore the purrr::is_*() family of functions.
```{r}
is.logical(v_log)
is.character(v_log)
```

- What do is.numeric(), is.integer(), and is.double() return for the vectors that hold floating point number versus integers?
```{r}
is.numeric(v_doub)
is.integer(v_doub)
is.double(v_doub)
```
Floating point is indeed numeric and double, so will return TRUE for those two.

- What happens when you ask for an element that is past the end of the vector, i.e. request x[k] when the length of x is less than k?

```{r}
v_char[10]
```
Displays NA.

- We indexed a vector x with a vector of positive integers that is shorter than x. What happens if the indexing vector is longer than x?

```{r}
v_int <- 1:10
v_char[v_int]
```
Displays NA.

- We indexed x with a logical vector of the same length. What happen if the indexing vector is shorter than x?

```{r}
v_int <- 1:3
v_char[v_int]
```
Displays values indexed by v_int from v_char 

- Recall the hieararchy of the most common atomic vector types: logical < integer < numeric < character. Try to use the as.*() functions to go the wrong way. Call as.logical(), as.integer(), and as.numeric() on a character vector, such as letters. What happens?

```{r}
as.logical(v_char)
as.integer(v_char)
as.numeric(v_char)
```
as.logical(v_char) converts the character list to the NA.

- Make the lists x, y, and z as shown above. Use is.star() functions to get to know these objects. Try to get some positive and negative results, i.e. establish a few things that x is and is NOT. Make sure to try is.list(), is.vector(), is.atomic(), and is.recursive(). Long-term, you may wish to explore the purrr::is_*() family of functions.
```{r}
(x <- list(1:3, c("four", "five")))
(y <- list(logical = TRUE, integer = 4L, double = 4 * 1.2, character = "character"))
(z <- list(letters[26:22], transcendental = c(pi, exp(1)), f = function(x) x^2))

is.double(x)
is.character(x)
is.atomic(x)
is.complex(x)
is.factor(x)
is.list(x)

is.double(y)
is.character(y)
is.atomic(y)
is.complex(y)
is.factor(y)
is.list(y)

is.double(z)
is.character(z)
is.atomic(z)
is.complex(z)
is.factor(z)
is.list(z)
```
All three are definitely a list.

- Use [, [[, and $ to access the second component of the list z, which bears the name “transcendental”. Use the length() and the is.*() functions explored elsewhere to study the result. Which methods of indexing yield the same result vs. different?
```{r}

```
- Use [ and [[ to attempt to retrieve elements 2 and 3 from my_vec and my_list. What succeeds vs. fails? What if you try to retrieve element 2 alone? Does [[ even work on atomic vectors? Compare and contrast the results from the various combinations of indexing method and input object.
```{r}
my_vec <- c(a = 1, b = 2, c = 3)
my_list <- list(a = 1, b = 2, c = 3)
```


####Relationship to base and plyr functions side-by-side workflow comparison

```{r}

```


##6. Work with a nested data frame

##Report your process

The progress report is in the [Readme file](https://github.com/ilgan/STAT545-hw-ganelin-ilya/blob/master/HW6/README.md)

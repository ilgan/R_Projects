---
title: "HW6"
author: "iganelin"
date: "`r format(Sys.Date())`"
output:
  github_document: default
---

#Homework 06: Data wrangling wrap up

### Loading libraries
```{r message=FALSE}
library(gapminder)
library(singer)
library(tidyverse)
library(knitr)
library(dplyr)
library(forcats)
library(plyr)
library(meme)
```

```{r message=FALSE, warning=FALSE, error=FALSE }
u <- "http://i0.kym-cdn.com/entries/icons/mobile/000/000/745/success.jpg"
#meme(u, "Homework 6", "Yes! Give me more!")
mmplot(u) + mm_caption("Homework 6", "Yes! Give me more!", color="purple")
```

##1. Character data

We wil start from the loading the libraries for this excercise.

```{r}
library(tidyverse)
library(stringr)
```
Lets write a few strings.
```{r}
string1 <- "This is definitely string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
str_c("x", "y", "z")
str_c(string1, ". ", string2)
#or
str_c(string1, string2, sep = ", ")
```

###14.2.5 Exercises

- In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions?

The difference between paste() and paste0() is that the argument "sep"" by default is ” ” (paste) and “” (paste0). It can be changed in the fuction itself.

- What stringr function are they equivalent to?

paste() => str_c(..., sep = " ", collapse = NULL)
paste0() => str_c(..., sep = "", collapse = NULL)

- How do the functions differ in their handling of NA?

Let's see how they work:
```{r}
str_c(c("a", NA, "b"), "-d")
paste(c("a", NA, "b"), "-d")
paste0(c("a", NA, "b"), "-d")
```
....so as we can see from the examples above, str_c does recognize NA, whereas paste() and paste0() both read NA as a string.

- In your own words, describe the difference between the sep and collapse arguments to str_c().

Argument "sep" is used when we want to insert a string between the input vectors.
Argument "collapse" is used when  we want to combine input vectors into one string.

- Use str_length() and str_sub() to extract the middle character from a string. 
```{r}
string <- "This is defiNitely string"
#string <- "12345" #for testing purposes
ln <- str_length(string)
str_sub(string, start=ln/2+1, end=ln/2+1)
```
- What will you do if the string has an even number of characters?

In that case we can extract the middle-1 or middle+1 character instead, or output "your character has even number of caracters" forcing the user to adjust the input string, and/or output an error.

- What does str_wrap() do? When might you want to use it?

```{r}
thanks_path <- file.path(R.home("doc"), "THANKS")
thanks <- str_c(readLines(thanks_path), collapse = "\n")
thanks <- word(thanks, 1, 3, fixed("\n\n"))
cat(str_wrap(thanks), "\n")
```

This is a wrapper around stri_wrap which implements the Knuth-Plass paragraph wrapping algorithm, where the function breaks text paragraphs into lines, of total width. We might wanna use it in the case when the lines' width is important, fixed screen sizes for example.

- What does str_trim() do? What’s the opposite of str_trim()?
```{r}
string <- "   This is definitely string   "
string
str_trim(string)
```
str_trim() - trims all the leading and trailing whitespaces from the string.
The opposite to str_trim() function is str_pad().

- Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.
```{r}
x = c("a", "b", "c")
y = c("")

func <- function(input) {
  output = ""
  if (length(input) == 1)
  {
    output <- str_c(input)
    writeLines("Your output is of the size 0") #zero length case
  }
  else if (length(input) == 2)
  {
    output <- str_c(output, input[1], " and ", input[2])
  }
  else
  {
    for (i in 1:(length(input)-2))
    {
      output <- str_c(output, input[i], ", ")
    }
    output <- str_c(output, input[length(input)-1], " and ", input[length(input)])
  }
  writeLines(output)
}

func(y)
func(x)
```

##2. Writing functions
- If you plan to complete the homework where we build an R package, write a couple of experimental functions exploring some functionality that is useful to you in real life and that might form the basis of your personal package.
We are going to use the data from the real wind turbine in form of csv. First function wil read this file and clean it up.

```{r}
read_wind_data <- function(input, save_flag){
  #Reads teh wind turbine data CSV, cleans and prints it out.
  gtm.rawData <- read.csv(input, header = TRUE)
  gtm.dat <- within(gtm.rawData, rm("X.GV.SD_04","X.GV.SD_05","X.GV.SD_38", "X.GV.HRR_GeneratorWindingTemp.1"))
  c_names <- colnames(gtm.dat, do.NULL = TRUE, prefix = "col")
  raw_data <- str_replace(c_names, "X.GV.", "")
  names(gtm.dat) <- raw_data

  return(gtm.dat)
}
```

Functoin creates dir in main folder
```{r}
gtm.dat <- read_wind_data("10.0.103.10.csv", FALSE)
```

```{r}
mkdirs <- function(fp) {
    if(!file.exists(fp)) {
        mkdirs(dirname(source_local(), fp))
        dir.create(fp)
    }
} 
```

Function plots var1 against var2 from data-frame df and saves if save_flag == TRUE:
```{r}
plot_and_save <- function(df, var1, var2, save_flag){
    my_plot <- ggplot(df, aes(df[[var1]], df[[var2]])) +
      geom_point() +
      geom_smooth(se=FALSE)
  
    if(save_flag == TRUE){
    #mkdirs(media)
      ggsave("media/my_plot.png", plot = my_plot)
    }
}
```

```{r}
plot_and_save(gtm.dat, "HRR_WTCorrectedWindSpeed", "HRR_kW", TRUE)
```

PCA plus Linear regression
```{r}
end = ncol(gtm.dat)
gtm.gentemp <- gtm.dat[,end]
gtm.vars <- gtm.dat[,3:end-1]

le_lin_fit <- function(vars, gentemp) {
  PCA <- prcomp(vars, center = TRUE, scale. = TRUE) 
  print(PCA$rotation)
  plot(PCA, type = "l")
  summary(PCA)
  #the_fit <- lm(gentemp ~ gtm.dat)
  #the_fit <- lm(gentemp ~ PCA$rotation[,1], PCA$rotation[,2])
  the_fit <- lm(gtm.gentemp ~ gtm.vars$HRR_kVAR + gtm.vars$HRR_WTCorrectedWindSpeed)
  coef(the_fit)
  }
le_lin_fit(gtm.vars, gtm.gentemp)
```


##3. Work with the candy data
- The ![excersise](http://stat545.com/hw07_2015_data-wrangling-candy.html) from 2015
- The original work ![here](https://github.com/jennybc/candy)

Calculate the joy/dispare scores in separate columns. Joy is (+1), Dispare is (+1), overall Joy - Dispare.
```{r message=FALSE, warning=FALSE}
library(readr)
suppressPackageStartupMessages(library(dplyr))
library(tidyr)
library(stringr)
library(ggplot2)

raw <- read_csv("CANDY-HIERARCHY-2015 SURVEY-Responses.csv",
                col_types = cols(
                  Timestamp = col_datetime("%m/%d/%Y %H:%M:%S")
                ))

raw_with_id <- raw %>%
  mutate(id = sprintf("ID%04d", row_number())) %>%
  select(id,
         age = starts_with("How"),
         everything())

raw_with_id_scores <- raw_with_id %>%
  mutate(j_score = apply(raw_with_id, 1, function(x) sum(x=="JOY", na.rm=TRUE))) %>% 
  mutate(d_score = apply(raw_with_id, 1, function(x) sum(x=="DESPAIR", na.rm=TRUE))) %>% 
  mutate(tot_score = j_score - d_score)
#View(raw_with_id_scores)
```

Copy the scores to the data frame. Adding some left_join practice, because why not? ;)
```{r message=FALSE, warning=FALSE}
#raw_with_id_scores$age <- factor(raw_with_id_scores$age)
age_joy_des <- raw_with_id_scores %>%
  group_by(age) %>%
  summarise(j_score_tot = sum(j_score))
  
age_des_des <- raw_with_id_scores %>%
  group_by(age) %>%
  summarise(d_score_tot = sum(d_score))

age_stats <- left_join(age_joy_des, age_des_des)
  
#View(age_stats)
age_stats
dat <- age_stats[!is.na(as.numeric(as.character(age_stats$age))) | !(age_stats$age>120),]
#dat1 <- dat[!(dat$age>120),]
  
plot1 <- ggplot(dat, aes(x = age, y = j_score_tot, color = age)) +
  geom_point()
plot(plot1)
#tim <- age_stats(age_stats$age == 33)
View(dat)
```


##4. Work with the singer data

##5. Work with a list

##6. Work with a nested data frame

##Report your process
